package io.supertokens.totp;

import java.security.InvalidKeyException;
import java.security.Key;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.time.Instant;
import java.util.Arrays;
import java.util.Base64;

import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import org.jetbrains.annotations.TestOnly;

import io.supertokens.Main;
import io.supertokens.config.Config;

import com.eatthepath.otp.TimeBasedOneTimePasswordGenerator;
import io.supertokens.pluginInterface.exceptions.StorageQueryException;
import io.supertokens.pluginInterface.exceptions.StorageTransactionLogicException;
import io.supertokens.pluginInterface.totp.TOTPDevice;
import io.supertokens.pluginInterface.totp.TOTPStorage;
import io.supertokens.pluginInterface.totp.TOTPUsedCode;
import io.supertokens.pluginInterface.totp.exception.DeviceAlreadyExistsException;
import io.supertokens.pluginInterface.totp.exception.TotpNotEnabledException;
import io.supertokens.pluginInterface.totp.exception.UnknownDeviceException;
import io.supertokens.pluginInterface.totp.sqlStorage.TOTPSQLStorage;
import io.supertokens.storageLayer.StorageLayer;
import io.supertokens.totp.exceptions.InvalidTotpException;
import io.supertokens.totp.exceptions.LimitReachedException;

public class Totp {
    private static String generateSecret() throws NoSuchAlgorithmException {
        // TODO: We can actually allow the user to choose this algorithm.
        // Changing it a would be rare but it can be a requirement for someone
        // who's dealing with unconventional totp apps/devices.
        final String TOTP_ALGORITHM = "HmacSHA1";

        final KeyGenerator keyGenerator = KeyGenerator.getInstance(TOTP_ALGORITHM);
        keyGenerator.init(160); // 160 bits = 20 bytes

        // FIXME: Should return base32 or base16
        // Return base64 string of the secret key:
        return Base64.getEncoder().encodeToString(keyGenerator.generateKey().getEncoded());
    }

    private static boolean checkCode(TOTPDevice device, String code) {
        final TimeBasedOneTimePasswordGenerator totp = new TimeBasedOneTimePasswordGenerator();

        byte[] keyBytes = Base64.getDecoder().decode(device.secretKey);
        Key key = new SecretKeySpec(keyBytes, "HmacSHA1");

        final int period = device.period;
        final int skew = device.skew;

        // Check if code is valid for any of the time periods in the skew:
        for (int i = -skew; i <= skew; i++) {
            try {
                // FIXME: Where is this using % on the period?
                if (totp.generateOneTimePasswordString(key, Instant.now().plusSeconds(i * period)).equals(code)) {
                    return true;
                }
            } catch (InvalidKeyException e) {
                return false;
            }
        }

        return false;
    }

    /**
     * Replicates TOTP code is generated by apps like Google Authenticator and Authy
     * 
     * @throws StorageQueryException
     */
    @TestOnly
    public static String generateTotpCode(Main main, String userId, String deviceName)
            throws InvalidKeyException, StorageQueryException {
        TOTPDevice[] devices = StorageLayer.getTOTPStorage(main).getDevices(userId);
        TOTPDevice device = Arrays.stream(devices).filter(d -> d.deviceName.equals(deviceName)).findFirst()
                .orElse(null);

        final TimeBasedOneTimePasswordGenerator totp = new TimeBasedOneTimePasswordGenerator();

        byte[] keyBytes = Base64.getDecoder().decode(device.secretKey);
        Key key = new SecretKeySpec(keyBytes, "HmacSHA1");

        return totp.generateOneTimePasswordString(key, Instant.now());
    }

    public static String registerDevice(Main main, String userId, String deviceName, int skew, int period)
            throws StorageQueryException, DeviceAlreadyExistsException, NoSuchAlgorithmException {

        TOTPSQLStorage totpStorage = StorageLayer.getTOTPStorage(main);

        // TODO: There should be a hard limit on number of devices per user
        // 8 devices per user should be enough. Otherwise, it is a security risk.

        String secret = generateSecret();
        TOTPDevice device = new TOTPDevice(userId, deviceName, secret, period, skew, false);
        totpStorage.createDevice(device);

        return secret;
    }

    private static void checkAndStoreCode(Main main, TOTPStorage totpStorage, String userId, TOTPDevice[] devices,
            String code)
            throws InvalidTotpException, StorageQueryException, TotpNotEnabledException, LimitReachedException {
        TOTPUsedCode[] usedCodes = totpStorage.getNonExpiredUsedCodes(userId);

        // N represents # of invalid attempts that will trigger rate limiting:
        int N = Config.getConfig(main).getTotpMaxAttempts(); // (Default 5)
        // Count # of contiguous invalids in latest N attempts (stop at first valid):
        long invalidOutOfN = Arrays.stream(usedCodes).limit(N).takeWhile(usedCode -> !usedCode.isValid).count();
        int rateLimitResetTimeInMs = Config.getConfig(main).getTotpRateLimitCooldownTime() * 1000; // (Default 15 mins)

        // Check if the user has been rate limited:
        if (invalidOutOfN == N) {
            // All of the latest N attempts were invalid:
            long latestInvalidCodeCreatedTime = usedCodes[0].createdTime;
            long now = System.currentTimeMillis();

            if (now - latestInvalidCodeCreatedTime < rateLimitResetTimeInMs) {
                // Less than rateLimitResetTimeInMs (default = 15 mins) time has elasped since
                // the last invalid code:
                throw new LimitReachedException();
            }
        }

        // Check if the code is valid for any device:
        boolean isValid = false;
        TOTPDevice matchingDevice = null;
        for (TOTPDevice device : devices) {
            // Check if the code is valid for this device:
            if (checkCode(device, code)) {
                isValid = true;
                matchingDevice = device;
                break;
            }
        }

        // Check if the code has been previously used by the user and it was valid (and
        // is still valid). If so, this could be a replay attack. So reject it.
        if (isValid) {
            for (TOTPUsedCode usedCode : usedCodes) {
                // One edge case is that if the user has 2 devices, and they are used back to
                // back (within 90 seconds) such that the code of the first device was
                // regenerated by the second device, then it won't allow the second device's
                // code to be used until it is expired.
                // But this would be rare so we can ignore it for now.
                if (usedCode.code.equals(code) && usedCode.isValid) {
                    isValid = false;
                    matchingDevice = null;
                }
            }
        }

        // Insert the code into the list of used codes:
        long now = System.currentTimeMillis();
        int expireInSec = isValid ? matchingDevice.period * (2 * matchingDevice.skew + 1) : 60 * 30; // 30 mins

        TOTPUsedCode newCode = new TOTPUsedCode(userId, code, isValid, now + 1000 * expireInSec, now);
        totpStorage.insertUsedCode(newCode);

        if (!isValid) {
            throw new InvalidTotpException();
        }
    }

    public static boolean verifyDevice(Main main, String userId, String deviceName, String code)
            throws StorageQueryException, TotpNotEnabledException, UnknownDeviceException, InvalidTotpException,
            LimitReachedException {
        // Here boolean return value tells whether the device has been
        // newly verified (true) OR it was already verified (false)

        TOTPSQLStorage totpStorage = StorageLayer.getTOTPStorage(main);
        TOTPDevice matchingDevice = null;

        // Check if the user has any devices:
        TOTPDevice[] devices = totpStorage.getDevices(userId);
        if (devices.length == 0) {
            throw new TotpNotEnabledException();
        }

        // Check if the requested device exists:
        for (TOTPDevice device : devices) {
            if (device.deviceName.equals(deviceName)) {
                matchingDevice = device;
                if (device.verified) {
                    return false; // Was already verified
                }
                break;
            }
        }

        // No device found:
        if (matchingDevice == null) {
            throw new UnknownDeviceException();
        }

        checkAndStoreCode(main, totpStorage, userId, new TOTPDevice[] { matchingDevice }, code);
        // Will reach here only if the code is valid:
        totpStorage.markDeviceAsVerified(userId, deviceName);
        return true; // Newly verified
    }

    public static void verifyCode(Main main, String userId, String code, boolean allowUnverifiedDevices)
            throws StorageQueryException, TotpNotEnabledException, InvalidTotpException,
            LimitReachedException {
        TOTPSQLStorage totpStorage = StorageLayer.getTOTPStorage(main);

        // Check if the user has any devices:
        TOTPDevice[] devices = totpStorage.getDevices(userId);
        if (devices.length == 0) {
            throw new TotpNotEnabledException();
        }

        // Filter out unverified devices:
        if (!allowUnverifiedDevices) {
            devices = Arrays.stream(devices).filter(device -> device.verified).toArray(TOTPDevice[]::new);
        }

        checkAndStoreCode(main, totpStorage, userId, devices, code);
    }

    /** Delete device and also delete the user if deleting the last device */
    public static void removeDevice(Main main, String userId, String deviceName)
            throws StorageQueryException, UnknownDeviceException, TotpNotEnabledException,
            StorageTransactionLogicException {
        TOTPSQLStorage storage = StorageLayer.getTOTPStorage(main);

        try {
            storage.startTransaction(con -> {
                int deletedCount = storage.deleteDevice_Transaction(con, userId, deviceName);
                if (deletedCount == 0)
                    throw new StorageTransactionLogicException(new UnknownDeviceException());

                // Some device(s) were deleted. Check if user has any other device left:
                int devicesCount = storage.getDevicesCount_Transaction(con, userId);
                if (devicesCount == 0) {
                    // no device left. delete user
                    storage.removeUser_Transaction(con, userId);
                }

                storage.commitTransaction(con);
                return null;
            });
            return;
        } catch (StorageTransactionLogicException e) {
            if (e.actualException instanceof UnknownDeviceException) {
                // Check if any device exists for the user:
                TOTPDevice[] devices = storage.getDevices(userId);
                if (devices.length == 0) {
                    throw new TotpNotEnabledException();
                }
            }

            throw e;
        }
    }

    public static void updateDeviceName(Main main, String userId, String oldDeviceName, String newDeviceName)
            throws StorageQueryException, DeviceAlreadyExistsException, UnknownDeviceException,
            TotpNotEnabledException {
        TOTPSQLStorage totpStorage = StorageLayer.getTOTPStorage(main);
        try {
            totpStorage.updateDeviceName(userId, oldDeviceName, newDeviceName);
        } catch (UnknownDeviceException e) {
            // Check if any device exists for the user:
            TOTPDevice[] devices = totpStorage.getDevices(userId);
            if (devices.length == 0) {
                throw new TotpNotEnabledException();
            } else {
                throw e;
            }
        }
    }

    public static TOTPDevice[] getDevices(Main main, String userId)
            throws StorageQueryException, TotpNotEnabledException {
        TOTPSQLStorage totpStorage = StorageLayer.getTOTPStorage(main);

        TOTPDevice[] devices = totpStorage.getDevices(userId);
        if (devices.length == 0) {
            throw new TotpNotEnabledException();
        }
        return devices;
    }

}
